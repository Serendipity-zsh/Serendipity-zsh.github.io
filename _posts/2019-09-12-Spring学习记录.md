---
layout: post
title: "Spring学习记录"
date: 2019-09-12
description: "Spring,学习记录"
tag: Spring
---

# Spring学习记录

## 知识点学习

### 1. Spring开发模式

工作流程：

+ Spring MVC 将所有用户的请求都提交给 DispatcherServlet（前端控制器），该控制器过滤出哪些请求可以访问Servlet ，哪些不能访问；即 url-pattern 的作用，并且会加载 springmvc.xml 配置文件
+ DispattcherServlet（前端控制器）查询一个或多个 HandlerMapping（处理器映射器），通过 HandlerMapping 完成 url 到 Controller 映射的组件，即将在 springmvc.xml 中配置的或者有注解的 url 与对应的处理类找到并进行存储，用Map<url,handler> 来存储（找到处理请求的 Controller ）
+ HandlerMapping （处理器映射器）有了映射关系，并且找到url对应的处理器，HandlerMapping （处理器映射器）就会将其处理器（Handler）返回，在返回前，会加上很多***
+ DispatcherServlet（前端控制器） 拿到 Handler （处理器）后，找到 HandlerAdapter（处理器适配器），通过它来访问处理器，并执行处理器。
+ 处理器会返回一个 ModelAndView 对象给 HandlerAdapter
+ 通过 HandlerAdapter （处理器适配器）将 ModelAndView 对象返回给前端控制器 (DispatcherServlet)
+ 前端控制器请求视图解析器 (ViewResolver) 去进行视图解析，根据逻辑视图名解析成真正的视图(jsp)，其实就是将ModelAndView 对象中存放视图的名称进行查找，找到对应的页面形成视图对象
+ 返回视图对象到前端控制器
+ 视图渲染，就是将 ModelAndView 对象中的数据放到 request 域中，用来让页面加载数据的

### 2. AOP（面向切面编程）

#### 技术优势

+ 将核心关注点与横切关注点**完全隔离**
+ 与传统 OOP 相比，传统 OOP 编程是**自顶向下**的编写主业务逻辑，但往往需要参杂着一些与主业务逻辑无关或关系不大的逻辑，这就产生了**横切性**问题。AOP 能很好的**隔离和管理**这些与主业务逻辑关联不大的业务代码，使得代码的**可读性**和**可维护性**大大提高



### 3. Spring Bean

#### 生命周期

+ 如果 Bean 类有实现 org.springframework.beans.factory.BeanFactoryAware 接口，工厂调用 setBeanFactory() 方法传入工厂自身
+ 可以在 Bean 定义文件中使用 "init-method" 属性，执行到这个阶段时，就会执行 initBean() 方法
+ 如果 Bean 类有实现 org.springframework.beans.factory.DisposableBean 接口，则执行他的 destroy() 方法



### 4. Spring 七大模块

#### 1. Spring Core

+ Core 封装包是框架的最基础部分，提供 IOC 和依赖注入
+  基础概念是BeanFactory ，它提供对 Factory 模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置



#### 2. Spring ORM

+ ORM 封装包提供了常用的“对象/关系”映射 APIs 的集成层
+ 其中包括 JPA 、JDO  Hibernate 和 MyBatis
+ 利用 ORM 封装包，可以混合使用所有 Spring 提供的特性进行“对象/关系”映射，如前边提到的简单声明性事务管理

#### 3. Spring DAO

+ Spring 提供对 JDBC 的支持，对 JDBC 进行封装，允许 JDBC 使用 Spring 资源，并能统一管理 JDBC事务，并不对 JDBC 进行实现

+ DAO (Data Access Object) 提供了JDBC 的抽象层
+ DAO 可消除冗长的 JDBC 编码和解析数据库厂商特有的错误代码
+ JDBC 封装包还提供了一种比编程性更好的声明性事务管理方法，不仅仅是实现了特定接口，而且对所有的 POJO （plain old Java objects）都适用



#### 4. Spring Web

+ Spring中的 Web 包提供了基础的针对Web开发的集成特性
+ 例如多方文件上传
+ 利用Servlet listeners进行IOC容器初始化
+ 针对Web的ApplicationContext
+ 当与WebWork或Struts一起使用Spring时，这个包使Spring可与其他框架结合。



#### 5. Spring Web MVC

+ Spring 中的 MVC 封装包提供了Web应用的 Model-View-Controller（MVC）实现
+ Spring的MVC框架并不是仅仅提供一种传统的实现，它提供了一种清晰的分离模型，在领域模型代码和Web Form之间。并且，还可以借助Spring框架的其他特性

#### 6. Spring Context

+ 构建于 Core 封装包基础上的  Context 封装包，提供了一种框架式的对象访问方法，有点像 JNDI 注册器
+ Context 封装包的特性得自于 Beans 封装包，并添加了对国际化（I18N）的支持（例如资源绑定），事件传播，资源装载的方式和 Context 的透明创建，比如说通过Servlet容器。



#### 7. Spring AOP

Spring 的 AOP 封装包提供了符合 AOP Alliance 规范的面向方面的编程实现

让你可以定义：

+ 例如方法拦截器（method-interceptors）和切点（pointcuts）
+ 从逻辑上讲，从而减弱代码的功能耦合，清晰的被分离开
+ 而且，利用 source-level 的元数据功能，还可以将各种行为信息合并到你的代码中



## 源码解读

### 1. 注解

#### 1. @Resource

用法与 @Autowired 用法类似，用做**依赖注入**，从容器中自动获取 Bean

+ 在启动 spring 的时候，首先要启动容器；
+ 启动 spring 容器时，会默认寻找容器扫描范围内的可加载 bean，然后查找哪些bean上的属性和方法上有 @Resource 注解；
+ 找到 @Resource 注解后，判断@Resource注解括号中的 name 属性是否为空，如果为空：看 spring 容器中的 bean 的 id 与 @Resource 要注解的那个变量属性名是否相同，如相同，匹配成功；如果不相同，看 spring 容器中 bean 的 id 对应的类型是否与 @Resource 要注解的那个变量属性对应的类型是否相等，若相等，匹配成功，若不相等，匹配失败。
+ 如果 @Resource 注解括号中的 name 属性不为空，看 name 的属性值和容器中的 bean 的 id 名是否相等，如相等，则匹配成功；如不相等，则匹配失败。

####  @Resource 与 @Autowired

**共同点**

+ @Resource 和 @Autowired 都可以作为注入属性的修饰，在接口仅有单一实现类时，两个注解的修饰效果相同，可以互相替换，不影响使用

**不同点**

+ @Resource 是 Java 自己的注解，@Resource 有两个属性是比较重要的，分是 name 和 type ；Spring 将 @Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入策略。如果既不指定 name 也不指定 type 属性，这时将通过反射机制使用 byName 自动注入策略。
+ @Autowired 是 Spring 的注解，是 Spring2.5 版本引入的，@Autowired 只根据 type 进行注入，不会去匹配 name。如果涉及到 type 无法辨别注入对象时，那需要依赖 **@Qualifier** 或 **@Primary** 注解一起来修饰

有关注解 @Resource 和 @Autowired 的具体区别，在另一篇[博客]([https://serendipity-zsh.github.io/2019/09/@Resource%E4%B8%8E@Autowired%E7%9A%84%E5%8C%BA%E5%88%AB/](https://serendipity-zsh.github.io/2019/09/@Resource与@Autowired的区别/))中通过一个springboot的demo解释



