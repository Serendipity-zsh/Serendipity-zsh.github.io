---
layout: post
title: "Java学习笔记"
description: "Java,基础,学习笔记"
date: 2019-09-23
tag: Java
---



# Java学习笔记

## 1. 集合框架

**重点：**

+ HashMap
+ HashTable
+ ConcurrentHashMap

### 1.1 集合框架设计要求

+ 高性能，基本集合（动态数组、链表、树、哈希表）的实现也必须是高效的;

+ 允许不同类型的集合，以类似方式工作，具有高度的互操作性;

+ 对一个集合的扩展和适应必须是高效的;

### 1.2 Java集合框架的类型

+ 集合（Collection）：存储一个元素值
+ 三种子类型：List、Set、Queue
+ 图（Map）：存储键/值对映射

### 1.3 集合框架内容

- **接口：**是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象
- **实现（类）：**是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap
- **算法：**是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。

<img src="/images/posts/Java/1.png"/>

### 1.4 集合接口



| 1    | Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。Collection 接口存储一组不唯一，无序的对象。 |
| ---- | ------------------------------------------------------------ |
| 2    | List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 |
| 3    | Set Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。 |
| 4    | SortedSet  继承于Set保存有序的集合。                         |
| 5    | Map Map 接口存储一组键值对象，提供key（键）到value（值）的映射。 |
| 6    | Map.Entry  描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。 |
| 7    | SortedMap 继承于 Map，使 Key 保持在升序排列。                |
| 8    | Enumeration 这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。 |

### 1.5 Set和List的区别

- 1. Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。
- 2. Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **<实现类有HashSet,TreeSet>**。
- 3. List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 **<实现类有ArrayList,LinkedList,Vector>** 。

### 1.6 LinkedList

```java
Listlist=Collections.synchronizedList(newLinkedList(...));
```

LinkedList 查找效率低。

### 1.7 ArrayList
+ 该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。

### 1.8 Vector 
+ 该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。

### 1.9 Stack 
+ 栈是Vector的一个子类，它实现了一个标准的后进先出的栈。

### 1.10 Properties 
+ Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。

### 1.11 HashSet
+ 该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。

### 1.12 HashMap

+ HashMap 是一个散列表，它存储的内容是键值对(key-value)映射
+ 该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，**不支持线程同步**

### 1.13 WeakHashMap 
+ 继承AbstractMap类，使用弱密钥的哈希表。

### 1.14 LinkedHashMap

+ 继承于HashMap，使用元素的自然顺序对元素进行排序.

### 1.15 LinkedHashSet

+ 具有可预知迭代顺序的 `Set` 接口的哈希表和链接列表实现。

## 2. 内存回收

+ jvm自动回收无用内存；
+ 不再引用的对象，可以把其引用赋为null; 
+ 也可以通过System.gc()来通知GC回收器回收，但只是建议，不能保证一定可以启动GC；



## 3. 编码和解码

1. String(byte[] bytes,String charsetName)

   通过使用指定的charset解码指定的byte数组，构建一个新的String

2. String.getbytes(Charset charset)

   按照指定的编码格式（charset）编码到byte，并存储到新的byte数组中

   例：

   ```java
   //将GBK编码转化为UTF-8
   byte[] a,b;
   a=new String(b,"GBK").getbytes("UTF-8");
   ```

## 4. 抽象类、接口

### 4.1 抽象类



### 4.2 接口



### 4.3 比较

|         特性         |      抽象类       |             接口              |
| :------------------: | :---------------: | :---------------------------: |
|       构造方法       |        Yes        |              No               |
|     普通成员变量     |        Yes        |              No               |
|      非抽象方法      |        Yes        |              No               |
|       访问类型       | public  protected | public(默认为public abstract) |
|       静态方法       |        Yes        |       No(Java8中可以有)       |
| 静态成员变量访问类型 |       任意        |   public static final(默认)   |
|     方法访问权限     |                   |         全都是public          |

## 5. 多线程

### 5.1 volatile和synchronize

volatile关键字：

本质：告诉JVM当前变量在寄存器中的值是**不确定的**，需要从**主存**中读取

+ 线程同步的轻量级实现，性能比synchronized要好
+ 只能修改变量
+ 多线程访问volatile不会发生阻塞
+ 能保证数据的可见性，不能保证原子性
+ 解决变量在多线程之间的可见性
+ 标记的变量不会被编译器优化
+ （可见性也就是说一旦某个线程修改了该被volatile修饰的变量，它会保证修改的值会**立即被更新到主存**，当有其他线程需要读取时，可以立即获取修改之后的值）；在Java中为了加快程序的运行效率，对一些变量的操作通常是在该线程的寄存器或是CPU缓存上进行的，之后才会同步到主存中，而加了volatile修饰的变量则是**直接读写主存**

synchronized：

本质：锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞

+ 可以修饰方法、代码块、变量
+ 多线程访问synchronized会出现阻塞
+ 可以保证数据的原子性，也可以间接保证可见性（因为它会将私有内存和公共内存中的数据做同步）
+ 解决多线程之间资源同步问题
+ 标记的变量可以被编译器优化

|              |             性能             |       修饰范围       | 多线程访问是否会出现阻塞 | 保证数据的性质 |          解决的问题          |
| :----------: | :--------------------------: | :------------------: | :----------------------: | :------------: | :--------------------------: |
|   volatile   | 线程同步的轻量级实现，性能好 |     只能修改变量     |           不会           |     原子性     | 解决变量在多线程之间的可见性 |
| synchronized |       性能差与volatile       | 可以修饰方法、代码块 |        会出现阻塞        | 原子性和可见性 |  解决多线程之间资源同步问题  |

## 6. 序列化

### 6.1 What 

#### 6.1.1 序列化(Serialization)

+ 将对象的状态信息转化为可以存储或者传输的形式的过程，一般将一个对象存储到一个储存媒介，例如档案或记忆体缓冲等；

+ 在网络传输过程中，可以是字节或者XML等格式；而字节或者XML格式的可以还原成完全相等的对象，这个相反的过程又称为反序列化

#### 6.1.2 Java对象的序列化和反序列化

+ 在Java中，我们可以通过多种方式来创建对象，并且只要对象没有被回收我们都可以复用此对象。但是，我们创建出来的这些对象都存在于JVM中的堆（heap）内存中，只有JVM处于运行状态的时候，这些对象才可能存在。一旦JVM停止，这些对象也就随之消失

+ 在真实的应用场景中，我们需要将这些对象持久化下来，并且在需要的时候将对象重新读取出来，Java的序列化可以帮助我们实现该功能

+ 对象序列化机制（object serialization）是java语言内建的一种对象持久化方式，通过对象序列化，可以将对象的状态信息保存未字节数组，并且可以在有需要的时候将这个字节数组通过反序列化的方式转换成对象，对象的序列化可以很容易的在JVM中的活动对象和字节数组（流）之间进行转换

+ 在JAVA中，对象的序列化和反序列化被广泛的应用到RMI（远程方法调用）及网络传输中

## 7. 参数传递

> **在Java中只有值传递**
>
> “传递引用” 本质上还是 “值传递”，只不过传递的是地址值

例如：

+ 在方法中，修改一个基础类型的参数不会影响原始参数值
+ 在方法中，改变一个对象参数的引用不会影响到原始引用，他只是会在堆中创建一个全新的对象
+ 在方法中，修改一个对象的属性会影响到原始对象参数
+ 在方法中，修改集合和Maps的元素会影响原始参数集合



## 8. 常用关键字

### 8.1 final

+ final修饰类，则类不能被继承
+ final修饰方法，则不可以被重写，但是可以被重载
+ final修饰变量，则等同于常量，不允许被再次赋值





## 9. 重载和重写

### 9.1 重载

+ 方法名相同，参数类型不同，包括但不限于一项：参数数目、参数类型、参数顺序



### 9.2 重写

要求：**两同两小一大**原则

+ 方法名相同，参数类型相同
+ 子类方法返回类型小于等于父类方法返回类型
+ 子类方法抛出异常小于等于父类方法抛出异常
+ 子类方法访问权限大于等于父类方法访问权限